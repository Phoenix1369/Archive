#define ALL(x) (x).begin(), (x).end()

class Solution {
    const static int MAXN = 305;
    int color[MAXN]{ };
    int sizec[MAXN]{ }; // color: size of component
    int    in[MAXN]{ }; // color: #nodes in init
    int  repn[MAXN]{ }; // color: representative
    int n;

    vector<vector<int>> G;
    
    void dfs(int cur) {
        ++sizec[color[cur]];
        for (int i = 0; i < n; ++i) {
            if (!color[i] && G[cur][i]) {
                color[i] = color[cur];
                dfs(i);
            }
        }
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        sort(ALL(initial));
        n = (int)graph.size();
        G = graph;
        for (int i = 0; i < n; ++i) {
            color[i] = 0;
            repn[i] = n;
        }
        // Floodfill
        int C = 1;
        for (int i = 0; i < n; ++i) {
            if (!color[i]) {
                color[i] = C++;
                dfs(i);
            }
        }
        // Candidate Components
        for (auto node: initial) {
            ++in[color[node]];
            repn[color[node]] = min(node, repn[color[node]]);
        }
        // Compute: maximal component with one node in initial of minimal index
        int best = -1;
        for (int i = 1; i < C; ++i) {
            if (in[i] == 1) {
                if (best == -1) {
                    best = repn[i];
                } else if (sizec[i] > sizec[color[best]]) {
                    best = repn[i];
                } else if ((sizec[i] == sizec[color[best]]) && (repn[i] < best)) {
                    best = repn[i];
                }
            }
        }
        if (best == -1) best = initial[0];
        return best;
    }
};
